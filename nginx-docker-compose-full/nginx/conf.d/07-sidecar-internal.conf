# Internal Sidecar Configuration
# This configuration handles internal service-to-service communication

# Internal service discovery
upstream internal_auth {
    server app-1:9001 weight=1;
    server app-2:9001 weight=1;
    keepalive 8;
}

upstream internal_metrics {
    server app-1:9002 weight=1;
    server app-2:9002 weight=1;
    keepalive 4;
}

upstream internal_logging {
    server app-1:9003 weight=1;
    server app-2:9003 weight=1;
    keepalive 4;
}

# Internal network server (no external access)
server {
    listen 8090;  # Internal port only
    server_name localhost;
    
    # Only allow internal networks
    allow 127.0.0.1;
    allow 10.0.0.0/8;
    allow 172.16.0.0/12;
    allow 192.168.0.0/16;
    deny all;
    
    # No external logging for internal traffic
    access_log off;
    
    # Internal service authentication
    location /internal/auth/ {
        proxy_pass http://internal_auth/;
        
        # Minimal headers for internal communication
        proxy_set_header Host $host;
        proxy_set_header X-Internal-Request "true";
        proxy_set_header X-Service-Name "nginx-sidecar";
        
        # Fast timeouts for internal services
        proxy_connect_timeout 1s;
        proxy_send_timeout 5s;
        proxy_read_timeout 5s;
        
        # No buffering for internal services
        proxy_buffering off;
        proxy_request_buffering off;
    }
    
    # Internal metrics collection
    location /internal/metrics/ {
        proxy_pass http://internal_metrics/;
        
        proxy_set_header Host $host;
        proxy_set_header X-Internal-Request "true";
        proxy_set_header X-Metrics-Source "nginx";
        
        # Even faster timeouts for metrics
        proxy_connect_timeout 500ms;
        proxy_send_timeout 2s;
        proxy_read_timeout 2s;
    }
    
    # Internal logging endpoint
    location /internal/logs/ {
        proxy_pass http://internal_logging/;
        
        proxy_set_header Host $host;
        proxy_set_header X-Internal-Request "true";
        proxy_set_header X-Log-Source "nginx";
        
        proxy_connect_timeout 500ms;
        proxy_send_timeout 3s;
        proxy_read_timeout 3s;
    }
    
    # Configuration reload endpoint
    location /internal/reload {
        access_log /var/log/nginx/internal.log;
        
        # Only allow specific methods
        if ($request_method !~ ^(POST|PUT)$) {
            return 405;
        }
        
        # Simulate configuration reload
        return 200 '{"status":"reload_triggered","timestamp":"$time_iso8601"}';
        add_header Content-Type application/json;
    }
    
    # Health check for internal services
    location /internal/health {
        # Check upstream services
        access_log off;
        
        # Simple aggregated health check
        proxy_pass http://internal_auth/health;
        proxy_next_upstream error timeout http_503;
        proxy_connect_timeout 1s;
        proxy_read_timeout 1s;
    }
}

# Sidecar proxy for external services
server {
    listen 8091;  # Sidecar port
    server_name localhost;
    
    # Allow internal and pod networks
    allow 127.0.0.1;
    allow 10.0.0.0/8;
    allow 172.16.0.0/12;
    allow 192.168.0.0/16;
    deny all;
    
    # Sidecar logging
    access_log /var/log/nginx/sidecar.access.log json_combined;
    
    # External API calls through sidecar
    location /external/ {
        # Remove /external prefix
        rewrite ^/external/(.*)$ /$1 break;
        
        # Proxy to actual external service
        proxy_pass http://backend_app;
        
        # Add sidecar identification
        proxy_set_header X-Sidecar-Proxy "nginx";
        proxy_set_header X-Sidecar-Version "1.0";
        proxy_set_header X-Request-ID $request_id;
        
        # Circuit breaker pattern
        proxy_next_upstream error timeout http_500 http_502 http_503;
        proxy_next_upstream_tries 2;
        proxy_next_upstream_timeout 3s;
        
        # Retry with exponential backoff
        proxy_connect_timeout 2s;
        proxy_send_timeout 10s;
        proxy_read_timeout 10s;
    }
    
    # Service mesh communication
    location /mesh/ {
        # Extract service name from path
        if ($uri ~ "^/mesh/([^/]+)/(.*)$") {
            set $service_name $1;
            set $service_path $2;
        }
        
        # Route to appropriate upstream based on service name
        if ($service_name = "auth") {
            proxy_pass http://internal_auth/$service_path;
        }
        if ($service_name = "metrics") {
            proxy_pass http://internal_metrics/$service_path;
        }
        if ($service_name = "logging") {
            proxy_pass http://internal_logging/$service_path;
        }
        
        # Service mesh headers
        proxy_set_header X-Service-Mesh "nginx";
        proxy_set_header X-Source-Service "nginx-sidecar";
        proxy_set_header X-Target-Service $service_name;
        proxy_set_header X-Request-ID $request_id;
        
        # Distributed tracing
        proxy_set_header X-Trace-ID $http_x_trace_id;
        proxy_set_header X-Span-ID $request_id;
    }
    
    # Interceptor for outgoing requests (egress)
    location /egress/ {
        # Log all outgoing requests
        access_log /var/log/nginx/egress.log json_combined;
        
        # Security scanning for outgoing requests
        if ($request_uri ~* "(\.exe|\.bat|\.cmd|malware)") {
            return 403 "Blocked potentially malicious request";
        }
        
        # Rate limiting for external calls
        limit_req zone=general burst=5 nodelay;
        
        # Remove egress prefix and proxy
        rewrite ^/egress/(.*)$ /$1 break;
        proxy_pass http://backend_app;
        
        # Add security headers
        proxy_set_header X-Egress-Proxy "nginx";
        proxy_set_header X-Security-Scan "passed";
    }
    
    # Local service registry
    location /registry/ {
        # Simple service discovery endpoint
        if ($arg_service = "auth") {
            return 200 '{"service":"auth","endpoints":["app-1:9001","app-2:9001"],"status":"healthy"}';
        }
        if ($arg_service = "metrics") {
            return 200 '{"service":"metrics","endpoints":["app-1:9002","app-2:9002"],"status":"healthy"}';
        }
        
        return 404 '{"error":"service_not_found","service":"$arg_service"}';
        add_header Content-Type application/json always;
    }
}

# Internal admin interface
server {
    listen 8092;  # Admin port
    server_name localhost;
    
    # Strict access control for admin
    allow 127.0.0.1;
    allow 10.0.0.1;  # Only specific admin IP
    deny all;
    
    # Admin logging
    access_log /var/log/nginx/admin.log json_combined;
    
    # Nginx status for monitoring
    location /admin/status {
        stub_status on;
        add_header Content-Type text/plain;
    }
    
    # Configuration status
    location /admin/config {
        return 200 '
        {
            "nginx_version": "$nginx_version",
            "server_name": "$server_name",
            "time": "$time_iso8601",
            "upstreams": {
                "internal_auth": "active",
                "internal_metrics": "active", 
                "internal_logging": "active"
            }
        }';
        add_header Content-Type application/json;
    }
    
    # Log rotation trigger
    location /admin/logs/rotate {
        if ($request_method != POST) {
            return 405;
        }
        
        return 200 '{"status":"log_rotation_triggered","time":"$time_iso8601"}';
        add_header Content-Type application/json;
    }
    
    # Cache management
    location /admin/cache/ {
        # Cache statistics and management
        if ($arg_action = "clear") {
            return 200 '{"status":"cache_cleared","time":"$time_iso8601"}';
        }
        if ($arg_action = "stats") {
            return 200 '{"cache_size":"unknown","hit_ratio":"unknown","time":"$time_iso8601"}';
        }
        
        return 400 '{"error":"invalid_action","valid_actions":["clear","stats"]}';
        add_header Content-Type application/json always;
    }
}